<project name="U8L1-RecursiveReporters" app="Snap! 9.0, https://snap.berkeley.edu" version="2"><notes></notes><thumbnail>data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAB4CAYAAAB1ovlvAAAAAXNSR0IArs4c6QAAAtRJREFUeF7t10Fqw1AQREHpRL7/LXyjH5JVCCShoXGDKa2HGVx6IHyfc87lITASuAU4knf2S0CAQpgKCHDK77gANTAVEOCU33EBamAqIMApv+MC1MBUQIBTfscFqIGpgACn/I4LUANTAQFO+R0XoAamAgKc8jsuQA1MBQQ45XdcgBqYCghwyu+4ADUwFRDglN9xAWpgKiDAKb/jAtTAVECAU37HBaiBqYAAp/yOC1ADUwEBTvkdF6AGpgICnPI7LkANTAUEOOV3XIAamAoIcMrvuAA1MBUQ4JTfcQFqYCogwCm/4wLUwFRAgFN+xwWogamAAKf8jgtQA1MBAU75HRegBqYCApzyOy5ADUwFBDjld1yAGpgKCHDK77gANTAVEOCU33EBamAqIMApv+MC1MBUQIC/8N/3fT2fz+vxeExf0LsfF+Afb/gzwu/POefde3j57xPgP+Q/IxRkt1EBCrBbVLhNgD7BYTLdcQH6E9ItKtwmwBDMeFdAgF1P20IBAYZgxrsCAux62hYKCDAEM94VEGDX07ZQQIAhmPGugAC7nraFAgIMwYx3BQTY9bQtFBBgCGa8KyDArqdtoYAAQzDjXQEBdj1tCwUEGIIZ7woIsOtpWyggwBDMeFdAgF1P20IBAYZgxrsCAux62hYKCDAEM94VEGDX07ZQQIAhmPGugAC7nraFAgIMwYx3BQTY9bQtFBBgCGa8KyDArqdtoYAAQzDjXQEBdj1tCwUEGIIZ7woIsOtpWyggwBDMeFdAgF1P20IBAYZgxrsCAux62hYKCDAEM94VEGDX07ZQQIAhmPGugAC7nraFAgIMwYx3BQTY9bQtFBBgCGa8KyDArqdtoYAAQzDjXQEBdj1tCwUEGIIZ7woIsOtpWyggwBDMeFdAgF1P20IBAYZgxrsCAux62hYKCDAEM94VEGDX07ZQQIAhmPGugAC7nraFAgIMwYx3BT4AoynwqCFalnsAAAAASUVORK5CYII=</thumbnail><scenes select="1"><scene name="U8L1-RecursiveReporters"><notes></notes><hidden></hidden><headers></headers><code></code><blocks><block-definition s="segments in tree %&apos;level&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doIfElse"><block s="reportVariadicEquals"><list><block var="level"/><l>1</l></list></block><script><block s="doReport"><l>1</l></block></script><script><block s="doReport"><block s="reportVariadicSum"><list><block s="reportVariadicProduct"><list><l>2</l><custom-block s="segments in tree %n"><block s="reportDifference"><block var="level"/><l>1</l></block></custom-block></list></block><l>1</l></list></block></block></script></block></script><scripts><script x="10" y="180.33333333333331"><block s="doIf"><block s="reportVariadicEquals"><list><block var="level"/><l>1</l></list></block><script><block s="doReport"><l>1</l></block></script><list></list></block><block s="doReport"><block s="reportVariadicSum"><list><block s="reportVariadicProduct"><list><l>2</l><custom-block s="segments in tree %n"><block s="reportDifference"><block var="level"/><l>1</l></block></custom-block></list></block><l>1</l></list></block></block></script></scripts></block-definition><block-definition s="alternate segments in tree %&apos;level&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doDeclareVariables"><list><l>result</l></list></block><block s="doSetVar"><l>result</l><l>0</l></block><block s="doRepeat"><block var="level"/><script><block s="doSetVar"><l>result</l><block s="reportVariadicSum"><list><block s="reportVariadicProduct"><list><l>2</l><block var="result"/></list></block><l>1</l></list></block></block></script></block><block s="doReport"><block var="result"/></block></script></block-definition><block-definition s="label %&apos;text&apos; of size %&apos;size&apos;" type="command" category="pen"><comment x="0" y="0" w="90" collapsed="false">LABEL will stamp text on the stage at the given font size. The direction of the text is the direction the sprite is facing, and color will match the pen color.</comment><header></header><code></code><translations></translations><inputs><input type="%txt">Hello!</input><input type="%n">12</input></inputs><script><block s="doRun"><block s="reportJSFunction"><list><l>text</l><l>size</l></list><l>var stage = this.parentThatIsA(StageMorph),&#xD;    context = stage.penTrails().getContext(&apos;2d&apos;),&#xD;    rotation = radians(this.direction() - 90),&#xD;    trans = new Point(&#xD;      this.center().x - stage.left(),&#xD;      this.center().y - stage.top()&#xD;    ),&#xD;    isWarped = this.Warped,&#xD;    len,&#xD;    pos;&#xD;&#xD;if (isWarped) {endWarp(); }&#xD;context.save();&#xD;context.font = size + &apos;px monospace&apos;;&#xD;context.textAlign = &apos;left&apos;;&#xD;context.textBaseline = &apos;alphabetic&apos;;&#xD;context.fillStyle = this.color.toString();&#xD;len = context.measureText(text).width;&#xD;trans = trans.multiplyBy(1 / stage.scale);&#xD;context.translate(trans.x, trans.y);&#xD;context.rotate(rotation);&#xD;context.fillText(text, 0, 0);&#xD;context.translate(-trans.x, -trans.y);&#xD;context.restore();&#xD;pos = new Point(&#xD;  len * Math.sin(radians(this.direction())),&#xD;  len * Math.cos(radians(this.direction())));&#xD;pos = pos.add(new Point(this.xPosition(), this.yPosition()));&#xD;this.gotoXY(pos.x, pos.y, false);&#xD;this.changed();&#xD;if (isWarped) {this.startWarp(); }&#xD;stage.changed();</l></block><list><block var="text"/><block var="size"/></list></block></script></block-definition><block-definition s="map %&apos;function&apos; over %&apos;lists&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%repRing"></input><input type="%mult%l"></input></inputs><script><block s="doWarp"><script><block s="doDeclareVariables"><list><l>mapone</l><l>mapmany</l></list></block><block s="doSetVar"><l>mapone</l><block s="reifyScript"><script><block s="doIf"><custom-block s="empty? %l"><block var="data"/></custom-block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><list></list></block><block s="doReport"><block s="reportCONS"><block s="evaluate"><block var="function"/><list><block s="reportListItem"><l>1</l><block var="data"/></block></list></block><block s="evaluate"><block var="mapone"/><list><block s="reportCDR"><block var="data"/></block></list></block></block></block></script><list><l>data</l></list></block></block><block s="doSetVar"><l>mapmany</l><block s="reifyScript"><script><block s="doIf"><custom-block s="empty? %l"><block s="reportListItem"><l>1</l><block var="data lists"/></block></custom-block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><list></list></block><block s="doReport"><block s="reportCONS"><block s="evaluate"><block var="function"/><custom-block s="map %repRing over %mult%l"><block s="reifyReporter"><autolambda><block s="reportListItem"><l>1</l><l/></block></autolambda><list></list></block><list><block var="data lists"/></list></custom-block></block><block s="evaluate"><block var="mapmany"/><list><custom-block s="map %repRing over %mult%l"><block s="reifyReporter"><autolambda><block s="reportCDR"><l/></block></autolambda><list></list></block><list><block var="data lists"/></list></custom-block></list></block></block></block></script><list><l>data lists</l></list></block></block><block s="doIfElse"><custom-block s="empty? %l"><block s="reportCDR"><block var="lists"/></block></custom-block><script><block s="doReport"><block s="evaluate"><block var="mapone"/><list><block s="reportListItem"><l>1</l><block var="lists"/></block></list></block></block></script><script><block s="doReport"><block s="evaluate"><block var="mapmany"/><list><block var="lists"/></list></block></block></script></block></script></block></script></block-definition><block-definition s="empty? %&apos;data&apos;" type="predicate" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><block s="reportVariadicEquals"><list><block var="data"/><block s="reportNewList"><list></list></block></list></block></block></script></block-definition><block-definition s="keep items such that %&apos;pred&apos; from %&apos;data&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%predRing"></input><input type="%l"></input></inputs><script><block s="doIf"><custom-block s="empty? %l"><block var="data"/></custom-block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><list></list></block><block s="doIfElse"><block s="evaluate"><block var="pred"/><list><block s="reportListItem"><l>1</l><block var="data"/></block></list></block><script><block s="doReport"><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="data"/></block><custom-block s="keep items such that %predRing from %l"><block var="pred"/><block s="reportCDR"><block var="data"/></block></custom-block></block></block></script><script><block s="doReport"><custom-block s="keep items such that %predRing from %l"><block var="pred"/><block s="reportCDR"><block var="data"/></block></custom-block></block></script></block></script><scripts><comment x="10" y="251.46666666666667" w="280.6666666666667" collapsed="true">This is the actual KEEP block from the tools library!</comment><comment x="8.666666666666666" y="282.8" w="406" collapsed="false">It&apos;s exactly the same as EVENS, ENDS-E, and NUMBERS except for the test that&apos;s applied to ITEM 1 OF the input.  To make that test, we have to CALL the predicate function we&apos;re given as the first input.  That input has to be declared as type Predicate.</comment></scripts></block-definition><block-definition s="combine with %&apos;function&apos; items of %&apos;data&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%repRing"></input><input type="%l"></input></inputs><script><block s="doIf"><custom-block s="empty? %l"><block s="reportCDR"><block var="data"/></block></custom-block><script><block s="doReport"><block s="reportListItem"><l>1</l><block var="data"/></block></block></script><list></list></block><block s="doReport"><block s="evaluate"><block var="function"/><list><block s="reportListItem"><l>1</l><block var="data"/></block><custom-block s="combine with %repRing items of %l"><block var="function"/><block s="reportCDR"><block var="data"/></block></custom-block></list></block></block></script><scripts><comment x="7.333333333333333" y="192.79999999999998" w="398" collapsed="false">This is the actual COMBINE block from the Tools library!&#xD;&#xD;To make this work we have to open up two input slots in the CALL block.  But there&apos;s nothing outside that; the CALL block is the combiner for the recursion -- it takes the place of APPEND or IN FRONT OF, not the place of &lt;(last letter)=E&gt; or&#xD;&lt;(number mod 2)=0&gt;.</comment></scripts></block-definition><block-definition s="if %&apos;test&apos; then %&apos;true&apos; else %&apos;false&apos;" type="reporter" category="control"><header></header><code></code><translations></translations><inputs><input type="%b"></input><input type="%anyUE"></input><input type="%anyUE"></input></inputs><script><block s="doIfElse"><block var="test"/><script><block s="doReport"><block s="evaluate"><block var="true"/><list></list></block></block></script><script><block s="doReport"><block s="evaluate"><block var="false"/><list></list></block></block></script></block></script></block-definition><block-definition s="for %&apos;i&apos; = %&apos;start&apos; to %&apos;end&apos; %&apos;action&apos;" type="command" category="control"><header></header><code></code><translations></translations><inputs><input type="%upvar"></input><input type="%n">1</input><input type="%n">10</input><input type="%cs"></input></inputs><script><block s="doDeclareVariables"><list><l>step</l><l>tester</l></list></block><block s="doIfElse"><block s="reportVariadicGreaterThan"><list><block var="start"/><block var="end"/></list></block><script><block s="doSetVar"><l>step</l><l>-1</l></block><block s="doSetVar"><l>tester</l><block s="reifyReporter"><autolambda><block s="reportVariadicLessThan"><list><block var="i"/><block var="end"/></list></block></autolambda><list></list></block></block></script><script><block s="doSetVar"><l>step</l><l>1</l></block><block s="doSetVar"><l>tester</l><block s="reifyReporter"><autolambda><block s="reportVariadicGreaterThan"><list><block var="i"/><block var="end"/></list></block></autolambda><list></list></block></block></script></block><block s="doSetVar"><l>i</l><block var="start"/></block><block s="doUntil"><block s="evaluate"><block var="tester"/><list></list></block><script><block s="doRun"><block var="action"/><list></list></block><block s="doChangeVar"><l>i</l><block var="step"/></block></script></block></script></block-definition><block-definition s="join words %&apos;words&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%mult%txt"></input></inputs><script><block s="doWarp"><script><block s="doIf"><custom-block s="empty? %l"><block s="reportCDR"><block var="words"/></block></custom-block><script><block s="doReport"><block s="reportListItem"><l>1</l><block var="words"/></block></block></script><list></list></block><block s="doReport"><block s="reportJoinWords"><list><block s="reportListItem"><l>1</l><block var="words"/></block><l> </l><custom-block s="join words %mult%txt"><block s="reportCDR"><block var="words"/></block></custom-block></list></block></block></script></block></script></block-definition><block-definition s="list $arrowRight sentence %&apos;data&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doWarp"><script><block s="doReport"><custom-block s="join words %mult%txt"><block var="data"/></custom-block></block></script></block></script></block-definition><block-definition s="sentence $arrowRight list %&apos;text&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%txt"></input></inputs><script><block s="doWarp"><script><block s="doReport"><block s="reportTextSplit"><block var="text"/><l><option>whitespace</option></l></block></block></script></block></script></block-definition><block-definition s="catch %&apos;tag&apos; %&apos;action&apos;" type="command" category="control"><header></header><code></code><translations></translations><inputs><input type="%upvar"></input><input type="%cs"></input></inputs><script><block s="doCallCC"><block s="reifyScript"><script><block s="doSetVar"><l>tag</l><block var="cont"/></block><block s="doRun"><block var="action"/><list></list></block></script><list><l>cont</l></list></block></block></script></block-definition><block-definition s="throw %&apos;cont&apos;" type="command" category="control"><header></header><code></code><translations></translations><inputs><input type="%s">catchtag</input></inputs><script><block s="doRun"><block var="cont"/><list></list></block></script></block-definition><block-definition s="catch %&apos;tag&apos; %&apos;value&apos;" type="reporter" category="control"><header></header><code></code><translations></translations><inputs><input type="%upvar"></input><input type="%anyUE"></input></inputs><script><block s="doCallCC"><block s="reifyScript"><script><block s="doSetVar"><l>tag</l><block var="cont"/></block><block s="doReport"><block s="evaluate"><block var="value"/><list></list></block></block></script><list><l>cont</l></list></block></block></script></block-definition><block-definition s="throw %&apos;tag&apos; %&apos;value&apos;" type="command" category="control"><header></header><code></code><translations></translations><inputs><input type="%s">catchtag</input><input type="%s"></input></inputs><script><block s="doRun"><block var="tag"/><list><block var="value"/></list></block></script></block-definition><block-definition s="for each %&apos;item&apos; of %&apos;data&apos; %&apos;action&apos;" type="command" category="lists"><header></header><code></code><translations></translations><inputs><input type="%upvar"></input><input type="%l"></input><input type="%cs"></input></inputs><script><block s="doUntil"><custom-block s="empty? %l"><block var="data"/></custom-block><script><block s="doSetVar"><l>item</l><block s="reportListItem"><l>1</l><block var="data"/></block></block><block s="doRun"><block var="action"/><list><block s="reportListItem"><l>1</l><block var="data"/></block></list></block><block s="doSetVar"><l>data</l><block s="reportCDR"><block var="data"/></block></block></script></block></script></block-definition><block-definition s="if %&apos;test&apos; do %&apos;action&apos; and pause all $pause-1-255-220-0" type="command" category="control"><header></header><code></code><translations></translations><inputs><input type="%boolUE"></input><input type="%cs"></input></inputs><script><block s="doDeclareVariables"><list><l>breakpoint</l></list></block><block s="doIf"><block s="evaluate"><block var="test"/><list></list></block><script><block s="doSetVar"><l>breakpoint</l><block var="test"/></block><block s="doShowVar"><l>breakpoint</l></block><block s="doRun"><block var="action"/><list></list></block><block s="doPauseAll"></block><block s="doHideVar"><l></l></block></script><list></list></block></script></block-definition><block-definition s="word $arrowRight list %&apos;word&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%txt"></input></inputs><script><block s="doWarp"><script><block s="doReport"><block s="reportTextSplit"><block var="word"/><l><option>letter</option></l></block></block></script></block></script></block-definition><block-definition s="ignore %&apos;x&apos;" type="command" category="control"><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs></block-definition><block-definition s="tell %&apos;sprite&apos; to %&apos;action&apos;" type="command" category="control"><header></header><code></code><translations></translations><inputs><input type="%s">Sprite</input><input type="%cs"></input></inputs><script><block s="doRun"><block s="reportAttributeOf"><block var="action"/><block var="sprite"/></block><list></list></block></script></block-definition><block-definition s="ask %&apos;sprite&apos; for %&apos;expression&apos;" type="reporter" category="control"><header></header><code></code><translations></translations><inputs><input type="%s">Sprite</input><input type="%repRing"></input></inputs><script><block s="doReport"><block s="evaluate"><block s="reportAttributeOf"><block var="expression"/><block var="sprite"/></block><list></list></block></block></script></block-definition><block-definition s="list $arrowRight word %&apos;list&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doWarp"><script><block s="doReport"><block s="reportJoinWords"><block var="list"/></block></block></script></block></script></block-definition><block-definition s="triangles in level %&apos;level&apos; fractal" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doIfElse"><block s="reportVariadicEquals"><list><block var="level"/><l>1</l></list></block><script><block s="doReport"><l>1</l></block></script><script><block s="doReport"><block s="reportVariadicSum"><list><l>1</l><block s="reportVariadicProduct"><list><l>3</l><custom-block s="triangles in level %n fractal"><block s="reportDifference"><block var="level"/><l>1</l></block></custom-block></list></block></list></block></block></script></block></script></block-definition><block-definition s="%&apos;n&apos; !" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doIfElse"><block s="reportVariadicEquals"><list><block var="n"/><l>1</l></list></block><script><block s="doReport"><l>1</l></block></script><script><block s="doReport"><block s="reportVariadicProduct"><list><block var="n"/><custom-block s="%n !"><block s="reportDifference"><block var="n"/><l>1</l></block></custom-block></list></block></block></script></block></script></block-definition><block-definition s="letter count %&apos;sentence&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIfElse"><block s="reportListIsEmpty"><block var="sentence"/></block><script><block s="doReport"><l>0</l></block></script><script><block s="doReport"><block s="reportVariadicSum"><list><block s="reportTextAttribute"><l><option>length</option></l><block s="reportListItem"><l>1</l><block var="sentence"/></block></block><custom-block s="letter count %l"><block s="reportCDR"><block var="sentence"/></block></custom-block></list></block></block></script></block></script><scripts><script x="10" y="199.16666666666669"><block s="doReport"><custom-block s="combine with %repRing items of %l"><block s="reifyReporter"><autolambda><block s="reportVariadicSum"><list><l></l><l></l></list></block></autolambda><list></list></block><custom-block s="map %repRing over %mult%l"><block s="reifyReporter"><autolambda><block s="reportTextAttribute"><l><option>length</option></l><l></l></block></autolambda><list></list></block><list><block var="sentence"/></list></custom-block></custom-block></block></script></scripts></block-definition><block-definition s="my join words %&apos;sentence&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIfElse"><block s="reportVariadicEquals"><list><block s="reportListAttribute"><l><option>length</option></l><block var="sentence"/></block><l>1</l></list></block><script><block s="doReport"><block s="reportListItem"><l>1</l><block var="sentence"/></block></block></script><script><block s="doReport"><block s="reportJoinWords"><list><block s="reportListItem"><l>1</l><block var="sentence"/></block><l> </l><custom-block s="my join words %l"><block s="reportCDR"><block var="sentence"/></block></custom-block></list></block></block></script></block></script></block-definition><block-definition s="earliest in %&apos;data&apos; recursive version" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIfElse"><custom-block s="empty? %l"><block s="reportCDR"><block var="data"/></block></custom-block><script><block s="doReport"><block s="reportListItem"><l>1</l><block var="data"/></block></block></script><script><block s="doDeclareVariables"><list><l>smaller</l></list><comment w="209.33333333333334" collapsed="true">script var for efficiency -- used twice</comment></block><block s="doSetVar"><l>smaller</l><custom-block s="earliest in %l recursive version"><block s="reportCDR"><block var="data"/></block></custom-block></block><block s="doIfElse"><block s="reportVariadicLessThan"><list><block s="reportListItem"><l>1</l><block var="data"/></block><block var="smaller"/></list><comment w="176" collapsed="false">The recursive call essentially reduces the number of candidates to two: the result reported by the recursive call, or the one item not included in the recursive call.  The inner IF/ELSE chooses one of those to report.</comment></block><script><block s="doReport"><block s="reportListItem"><l>1</l><block var="data"/></block></block></script><script><block s="doReport"><block var="smaller"/></block></script></block></script></block></script><scripts><comment x="20.66666666666663" y="305.46666666666664" w="400" collapsed="false">In this code, the use of the script variable to avoid making the same recursive call twice makes a huge difference in run time.  This version is quadratic time; the version with the recursive call repeated takes exponential time.</comment></scripts></block-definition><block-definition s="earliest in %&apos;data&apos; HOF version" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><custom-block s="combine with %repRing items of %l"><block s="reifyReporter"><autolambda><custom-block s="min %s %s"><l></l><l></l></custom-block></autolambda><list></list></block><block var="data"/></custom-block></block></script><scripts><comment x="10" y="94.80000000000001" w="364.6666666666667" collapsed="true">MIN is a helper block I defined that reports the smaller of its two inputs.</comment></scripts></block-definition><block-definition s="min %&apos;a&apos; %&apos;b&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%s"></input></inputs><script><block s="doReport"><custom-block s="if %b then %anyUE else %anyUE"><block s="reportVariadicLessThan"><list><block var="a"/><block var="b"/></list></block><block var="a"/><block var="b"/></custom-block></block></script></block-definition><block-definition s="earliest in %&apos;data&apos; iterative version" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doDeclareVariables"><list><l>smallest candidate</l></list></block><block s="doSetVar"><l>smallest candidate</l><block s="reportListItem"><l>1</l><block var="data"/></block></block><custom-block s="for each %upvar of %l %cs"><l>item</l><block var="data"/><script><block s="doIf"><block s="reportVariadicLessThan"><list><block var="item"/><block var="smallest candidate"/></list></block><script><block s="doSetVar"><l>smallest candidate</l><block var="item"/></block></script><list></list></block></script></custom-block><block s="doReport"><block var="smallest candidate"/></block></script></block-definition><block-definition s="earliest in %&apos;data&apos; another iteratiive version" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doDeclareVariables"><list><l>smallest candidate</l></list></block><block s="doSetVar"><l>smallest candidate</l><block s="reportListItem"><l>1</l><block var="data"/></block></block><custom-block s="for %upvar = %n to %n %cs"><l>i</l><l>2</l><block s="reportListAttribute"><l><option>length</option></l><block var="data"/></block><script><block s="doIf"><block s="reportVariadicLessThan"><list><block s="reportListItem"><block var="i"/><block var="data"/></block><block var="smallest candidate"/></list></block><script><block s="doSetVar"><l>smallest candidate</l><block s="reportListItem"><block var="i"/><block var="data"/></block></block></script><list></list></block></script><comment w="104" collapsed="false">Assumes at least two items in the list.</comment></custom-block><block s="doReport"><block var="smallest candidate"/></block></script><scripts><comment x="10.666666666666629" y="228.79999999999995" w="306" collapsed="false">This version uses abstraction less than the FOR EACH ITEM version, since that one hides the mechanism of stepping an index into the list.  But this is the one that students who&apos;ve programmed before in something like Java will probably write.</comment></scripts></block-definition><block-definition s="index of %&apos;value&apos; in %&apos;data&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%l"></input></inputs><script><custom-block s="for %upvar = %n to %n %cs"><l>i</l><l>1</l><block s="reportListAttribute"><l><option>length</option></l><block var="data"/></block><script><block s="doIf"><block s="reportVariadicEquals"><list><block var="value"/><block s="reportListItem"><block var="i"/><block var="data"/></block></list></block><script><block s="doReport"><block var="i"/></block></script><list></list></block></script></custom-block><block s="doReport"><l>Not found</l></block></script></block-definition><block-definition s="earliest in %&apos;data&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIfElse"><custom-block s="empty? %l"><block s="reportCDR"><block var="data"/></block></custom-block><script><block s="doReport"><block s="reportListItem"><l>1</l><block var="data"/></block></block></script><script><block s="doDeclareVariables"><list><l>smaller</l></list><comment w="209.33333333333334" collapsed="true">script var for efficiency -- used twice</comment></block><block s="doSetVar"><l>smaller</l><custom-block s="earliest in %l recursive version"><block s="reportCDR"><block var="data"/></block></custom-block></block><block s="doIfElse"><block s="reportVariadicLessThan"><list><block s="reportListItem"><l>1</l><block var="data"/></block><block var="smaller"/></list><comment w="176" collapsed="false">The recursive call essentially reduces the number of candidates to two: the result reported by the recursive call, or the one item not included in the recursive call.  The inner IF/ELSE chooses one of those to report.</comment></block><script><block s="doReport"><block s="reportListItem"><l>1</l><block var="data"/></block></block></script><script><block s="doReport"><block var="smaller"/></block></script></block></script></block></script></block-definition><block-definition s="index of earliest in %&apos;data&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doDeclareVariables"><list><l>candidate index</l><l>candidate value</l></list></block><block s="doSetVar"><l>candidate index</l><l>1</l></block><block s="doSetVar"><l>candidate value</l><block s="reportListItem"><l>1</l><block var="data"/></block></block><custom-block s="for %upvar = %n to %n %cs"><l>i</l><l>2</l><block s="reportListAttribute"><l><option>length</option></l><block var="data"/></block><script><block s="doIf"><block s="reportVariadicLessThan"><list><block s="reportListItem"><block var="i"/><block var="data"/></block><block var="candidate value"/></list></block><script><block s="doSetVar"><l>candidate index</l><block var="i"/></block><block s="doSetVar"><l>candidate value</l><block s="reportListItem"><block var="i"/><block var="data"/></block></block></script><list></list></block></script><comment w="96" collapsed="false">Assumes at least two items in the list.</comment></custom-block><block s="doReport"><block var="candidate index"/></block></script></block-definition><block-definition s="remove value %&apos;value&apos; from %&apos;list&apos; HOF version" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%l"></input></inputs><script><block s="doReport"><custom-block s="keep items such that %predRing from %l"><block s="reifyPredicate"><autolambda><block s="reportNot"><block s="reportVariadicEquals"><list><l></l><block var="value"/></list></block></block></autolambda><list></list></block><block var="list"/></custom-block></block></script></block-definition><block-definition s="remove value at index %&apos;index&apos; from %&apos;list&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportVariadicEquals"><list><block var="index"/><l>1</l></list><comment w="90" collapsed="true">Base case</comment></block><script><block s="doReport"><block s="reportCDR"><block var="list"/></block></block></script><list></list></block><block s="doReport"><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="list"/></block><custom-block s="remove value at index %n from %l"><block s="reportDifference"><block var="index"/><l>1</l></block><block s="reportCDR"><block var="list"/></block></custom-block></block></block></script><scripts><comment x="8.666666666666666" y="179.46666666666667" w="397.3333333333333" collapsed="false">Students will probably find this weird at first, but it&apos;s important for them to understand how it works.  If it&apos;s the first item we want to remove, there&apos;s a primitive function that does exactly what we want -- ALL BUT FIRST OF.   If not, then *we want to keep item 1 in the result*.  So we combine item 1 with the result of a recursive call to remove the value from the rest of the list.  But if we want, say, item 4 of the input list, that&apos;s item *3* of ALL BUT FIRST OF the list.</comment></scripts></block-definition><block-definition s="remove value %&apos;value&apos; from %&apos;data&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%s"></input><input type="%l"></input></inputs><script><block s="doIfElse"><block s="reportVariadicEquals"><list><block var="value"/><block s="reportListItem"><l>1</l><block var="data"/></block></list></block><script><block s="doReport"><block s="reportCDR"><block var="data"/></block></block></script><script><block s="doReport"><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="data"/></block><custom-block s="remove value %s from %l"><block var="value"/><block s="reportCDR"><block var="data"/></block></custom-block></block></block></script></block></script><scripts><comment x="19.33333333333337" y="196.79999999999995" w="356" collapsed="false">Some students find this sort of composition of functions really hard to read, and prefer seeing each sub-computation done separately, like this:</comment><script x="15.666666666666629" y="256.8"><block s="doDeclareVariables"><list><l>first</l><l>rest</l><l>rest-with-value-removed</l></list></block><block s="doSetVar"><l>first</l><block s="reportListItem"><l>1</l><block var="data"/></block></block><block s="doSetVar"><l>rest</l><block s="reportCDR"><block var="data"/></block></block><block s="doSetVar"><l>rest-with-value-removed</l><custom-block s="remove value %s from %l"><block var="value"/><block var="rest"/></custom-block></block><block s="doReport"><block s="reportCONS"><block var="first"/><block var="rest-with-value-removed"/></block></block></script><comment x="15.333333333333371" y="393.46666666666664" w="381.3333333333333" collapsed="false">It&apos;s fine to show them this version as a pedagogic technique, but think of it as training wheels that they should plan not to need eventually.</comment></scripts></block-definition><block-definition s="selection sort %&apos;data&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIfElse"><custom-block s="empty? %l"><block var="data"/><comment w="179.33333333333334" collapsed="true">EMPTY? is in the Tools library.</comment></custom-block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><script><block s="doDeclareVariables"><list><l>smallest</l></list></block><block s="doSetVar"><l>smallest</l><custom-block s="earliest in %l"><block var="data"/></custom-block></block><block s="doReport"><block s="reportCONS"><block var="smallest"/><custom-block s="selection sort %l"><custom-block s="remove value %s from %l"><block var="smallest"/><block var="data"/></custom-block></custom-block></block></block></script></block></script><scripts><comment x="12" y="230.13333333333333" w="388.6666666666667" collapsed="false">Isn&apos;t this elegant?  The result of sorting a list consists of the smallest item in front of the result of sorting the other items.&#xD;&#xD;We use the script variable to avoid calling EARLIEST IN twice.  How inefficient would that be?  As long as it&apos;s not *the recursive call* we do twice, it&apos;s not that bad, just twice the total run time.  You could leave out the script variable and just say</comment><script x="14.000000000000002" y="344.1333333333334"><block s="doReport"><block s="reportCONS"><custom-block s="earliest in %l"><block var="data"/></custom-block><custom-block s="selection sort %l"><custom-block s="remove value %s from %l"><custom-block s="earliest in %l"><block var="data"/></custom-block><block var="data"/></custom-block></custom-block></block></block></script></scripts></block-definition><block-definition s="names starting with %&apos;letter&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doReport"><custom-block s="selection sort %l"><custom-block s="keep items such that %predRing from %l"><block s="reifyPredicate"><autolambda><block s="reportVariadicEquals"><list><block s="reportLetter"><l>1</l><l></l></block><block var="letter"/></list></block></autolambda><list></list></block><block var="big name list"/></custom-block></custom-block></block></script><scripts><comment x="9.333333333333334" y="130.79999999999998" w="414.6666666666667" collapsed="false">Assuming that BIG NAME LIST is a global variable containing the imported list.&#xD;&#xD;Even though we&apos;re studying recursive functions, I wasn&apos;t even slightly tempted to rewrite KEEP recursively for this problem, much less attempt a function that does the filtering and the sorting all at once.</comment></scripts></block-definition><block-definition s="partition sort %&apos;data&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIfElse"><custom-block s="empty? %l"><block var="data"/></custom-block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><script><block s="doDeclareVariables"><list><l>pivot</l></list></block><block s="doSetVar"><l>pivot</l><block s="reportListItem"><l>1</l><block var="data"/></block><comment w="186" collapsed="false">Since we want the two sublists to sort recursively to be about equal in size, it&apos;s tempting to compute the average of the list items and use that.  But it&apos;s important that the pivot actually be an item in the list, which won&apos;t generally be true of the average, because that&apos;s what guarantees that even in the worst case, when the pivot turns out to be the smallest or largest value, the recursive list to sort is smaller than the input list by at least that one item.  It would be perfect if we could find the *median* value, but to do that you need the list already in order!</comment></block><block s="doReport"><custom-block s="append %mult%l"><list><custom-block s="partition sort %l"><custom-block s="keep items such that %predRing from %l"><block s="reifyPredicate"><autolambda><block s="reportVariadicLessThan"><list><l></l><block var="pivot"/></list></block></autolambda><list></list></block><block var="data"/></custom-block></custom-block><custom-block s="keep items such that %predRing from %l"><block s="reifyPredicate"><autolambda><block s="reportVariadicEquals"><list><l></l><block var="pivot"/></list></block></autolambda><list></list></block><block var="data"/></custom-block><custom-block s="partition sort %l"><custom-block s="keep items such that %predRing from %l"><block s="reifyPredicate"><autolambda><block s="reportVariadicGreaterThan"><list><l></l><block var="pivot"/></list></block></autolambda><list></list></block><block var="data"/></custom-block></custom-block></list></custom-block></block></script></block></script><scripts><comment x="17.333333333333332" y="312.8" w="396" collapsed="false">This is another case in which students may find it easier to read the code without the composition of functions (but remember the note about training wheels earlier):</comment><script x="17" y="378.1333333333334"><block s="doDeclareVariables"><list><l>pivot</l><l>smaller items</l><l>smaller items sorted</l><l>equal items</l><l>larger items</l><l>larger items sorted</l></list></block><block s="doSetVar"><l>pivot</l><block s="reportListItem"><l>1</l><block var="data"/></block></block><block s="doSetVar"><l>smaller items</l><custom-block s="keep items such that %predRing from %l"><block s="reifyPredicate"><autolambda><block s="reportVariadicLessThan"><list><l></l><block var="pivot"/></list></block></autolambda><list></list></block><block var="data"/></custom-block></block><block s="doSetVar"><l>smaller items sorted</l><custom-block s="partition sort %l"><block var="smaller items"/></custom-block></block><block s="doSetVar"><l>equal items</l><custom-block s="keep items such that %predRing from %l"><block s="reifyPredicate"><autolambda><block s="reportVariadicEquals"><list><l></l><block var="pivot"/></list></block></autolambda><list></list></block><block var="data"/></custom-block></block><block s="doSetVar"><l>larger items</l><custom-block s="keep items such that %predRing from %l"><block s="reifyPredicate"><autolambda><block s="reportVariadicGreaterThan"><list><l></l><block var="pivot"/></list></block></autolambda><list></list></block><block var="data"/></custom-block></block><block s="doSetVar"><l>larger items sorted</l><custom-block s="partition sort %l"><block var="larger items"/></custom-block></block><block s="doReport"><custom-block s="append %mult%l"><list><block var="smaller items sorted"/><block var="equal items"/><block var="larger items sorted"/></list></custom-block></block></script></scripts></block-definition><block-definition s="append %&apos;lists&apos;" type="reporter" category="lists"><comment x="0" y="0" w="287" collapsed="false">Take any number of input lists, and create a new list containing the items of the input lists.  So&#xD;              APPEND [A B] [C D]&#xD;where the [,,,] are lists reports the list&#xD;              [A B C D]&#xD;not [[A B] [C D]].</comment><header></header><code></code><translations></translations><inputs><input type="%mult%l"></input></inputs><script><block s="doWarp"><script><block s="doIf"><block s="reportVariadicEquals"><list><block var="lists"/><block s="reportNewList"><list></list></block></list></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><list></list></block><block s="doIf"><block s="reportVariadicEquals"><list><block s="reportListAttribute"><l><option>length</option></l><block var="lists"/></block><l>1</l></list></block><script><block s="doReport"><block s="reportListItem"><l>1</l><block var="lists"/></block></block></script><list></list></block><block s="doIf"><block s="reportVariadicEquals"><list><block s="reportListItem"><l>1</l><block var="lists"/></block><block s="reportNewList"><list></list></block></list></block><script><block s="doReport"><custom-block s="append %mult%l"><block s="reportCDR"><block var="lists"/></block></custom-block></block></script><list></list></block><block s="doReport"><block s="reportCONS"><block s="reportListItem"><l>1</l><block s="reportListItem"><l>1</l><block var="lists"/></block></block><custom-block s="append %mult%l"><block s="reportCONS"><block s="reportCDR"><block s="reportListItem"><l>1</l><block var="lists"/></block></block><block s="reportCDR"><block var="lists"/></block></block></custom-block></block></block></script></block></script></block-definition><block-definition s="reverse %&apos;data&apos;" type="reporter" category="lists"><comment x="0" y="0" w="222.99999999999997" collapsed="false">Reports a new list containing the items of the input list, but in the opposite order.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doDeclareVariables"><list><l>helper</l></list></block><block s="doSetVar"><l>helper</l><block s="reifyScript"><script><block s="doIf"><block s="reportVariadicEquals"><list><block var="input"/><block s="reportNewList"><list></list></block></list></block><script><block s="doReport"><block var="result"/></block></script><list></list></block><block s="doReport"><block s="evaluate"><block var="helper"/><list><block s="reportCDR"><block var="input"/></block><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="input"/></block><block var="result"/></block></list></block></block></script><list><l>input</l><l>result</l></list></block></block><block s="doWarp"><script><block s="doReport"><block s="evaluate"><block var="helper"/><list><block var="data"/><block s="reportNewList"><list></list></block></list></block></block></script></block></script></block-definition><block-definition s="remove duplicates from %&apos;data&apos;" type="reporter" category="lists"><comment x="0" y="0" w="209" collapsed="false">Reports a new list whose items are the same as in the input list, except that if two or more equal items appear in the input list, only the last one is kept in the result.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doWarp"><script><block s="doIf"><block s="reportVariadicEquals"><list><block var="data"/><block s="reportNewList"><list></list></block></list></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><list></list></block><block s="doIfElse"><block s="reportListContainsItem"><block s="reportCDR"><block var="data"/></block><block s="reportListItem"><l>1</l><block var="data"/></block></block><script><block s="doReport"><custom-block s="remove duplicates from %l"><block s="reportCDR"><block var="data"/></block></custom-block></block></script><script><block s="doReport"><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="data"/></block><custom-block s="remove duplicates from %l"><block s="reportCDR"><block var="data"/></block></custom-block></block></block></script></block></script></block></script></block-definition><block-definition s="sort %&apos;data&apos; using %&apos;function&apos; to compare" type="reporter" category="lists"><comment x="0" y="0" w="204" collapsed="false">Reports a sorted version of the list in its first input slot, using the comparison function in the second input slot.  For a list of numbers, using &lt; as the comparison function will sort from low to high; using &gt; will sort from high to low.</comment><header></header><code></code><translations></translations><inputs><input type="%l"></input><input type="%predRing"></input></inputs><script><block s="doIf"><custom-block s="empty? %l"><block var="data"/></custom-block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><list></list></block><block s="doDeclareVariables"><list><l>insert</l></list></block><block s="doSetVar"><l>insert</l><block s="reifyScript"><script><block s="doIf"><custom-block s="empty? %l"><block var="already sorted"/></custom-block><script><block s="doReport"><block s="reportNewList"><list><block var="new"/></list></block></block></script><list></list></block><block s="doIf"><block s="evaluate"><block var="function"/><list><block var="new"/><block s="reportListItem"><l>1</l><block var="already sorted"/></block></list></block><script><block s="doReport"><block s="reportNewList"><list><block var="new"/><block var="already sorted"/></list></block></block></script><list></list></block><block s="doReport"><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="already sorted"/></block><block s="evaluate"><block var="insert"/><list><block var="new"/><block s="reportCDR"><block var="already sorted"/></block></list></block></block></block></script><list><l>new</l><l>already sorted</l></list></block><comment w="152" collapsed="false">We&apos;re using the INSERTION SORT algorithm -- different from the two shown in 7.2.&#xD;&#xD;This helper function reports the result of inserting a new item into its proper position in an already sorted list.&#xD;&#xD;CALL (FUNCTION)... is the test for whether the new item belongs in front of the list.&#xD;&#xD;CALL (INSERT)... is the recursive call to this helper.</comment></block><block s="doReport"><block s="evaluate"><block var="insert"/><list><block s="reportListItem"><l>1</l><block var="data"/></block><custom-block s="sort %l using %predRing to compare"><block s="reportCDR"><block var="data"/></block><block var="function"/></custom-block></list></block><comment w="176.66666666666666" collapsed="false">Once we have INSERT, the actual sort function (minus the base case, which is up at the top) just inserts the first item of the input (not necessarily the one that should come first in the result!) into the result of recursively sorting the other items.</comment></block></script><scripts><comment x="12.666666666666666" y="442.1333333333334" w="326.6666666666667" collapsed="false">I could have defined an INSERT block separate from the SORT block, but now that we know about functions as data, it might be interesting for students to see how to create a function inside another function.  In the SET [INSERT]... block, I used an explicit grey ring from the top of the Operators palette.  I clicked its right arrowhead to give it explicit input names (formal parameters).</comment></scripts></block-definition><block-definition s="next row %&apos;row&apos; HOF version" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><block s="reportCONS"><l>1</l><custom-block s="map %repRing over %mult%l"><block s="reifyReporter"><autolambda><block s="reportVariadicSum"><list><l></l><l></l></list></block></autolambda><list></list></block><list><block var="row"/><block s="reportCDR"><block var="row"/></block></list></custom-block></block></block></script><scripts><comment x="7.333333333333333" y="106.8" w="427.3333333333333" collapsed="false">Students aren&apos;t expected to come up with this solution, but it&apos;s the most elegant way to solve this problem.  The IN FRONT OF is needed because the reported list should have one more item than the input list, so we supply that item explicitly.&#xD;&#xD;This call to MAP has a second list input, one of the rare times in this curriculum that we have a use for the ability of MAP to handle multiple lists in parallel.  Because there are two lists, the function has to take two inputs, applied to corresponding items of the two lists:&#xD;&#xD;&#xD;row                          1    4    6    4    1&#xD;all but first of row     4    6    4    1&#xD;&#xD;result                        5  10   10   5   1&#xD;&#xD;The last item of ROW has no corresponding item in ALL BUT FIRST OF ROW.  Here&apos;s a case in which we benefit from the convention that an empty input in a numeric slot means zero!</comment></scripts></block-definition><block-definition s="next row %&apos;row&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doReport"><block s="reportCONS"><l>1</l><custom-block s="next row helper %l"><block var="row"/></custom-block></block></block></script></block-definition><block-definition s="next row helper %&apos;row&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIfElse"><block s="reportVariadicEquals"><list><block s="reportListAttribute"><l><option>length</option></l><block var="row"/></block><l>1</l></list></block><script><block s="doReport"><block var="row"/></block></script><script><block s="doReport"><block s="reportCONS"><block s="reportVariadicSum"><list><block s="reportListItem"><l>1</l><block var="row"/></block><block s="reportListItem"><l>2</l><block var="row"/></block></list></block><custom-block s="next row helper %l"><block s="reportCDR"><block var="row"/></block></custom-block></block></block></script></block></script><scripts><comment x="8.666666666666666" y="196.13333333333333" w="484" collapsed="false">This is essentially the same pattern as the recursive list functions from Lab 2:&#xD;REPORT (some-fiunction-of(ITEM 1 OF input)) IN FRONT OF (recursive-call(ALL BUT FIRST OF input))&#xD;except that the function, +, also takes the second item as input.  Because the function needs two list items, the base case isn&apos;t an empty list, but a list with only one item.&#xD;&#xD;The other new thing in this solution is that the result returned by the recursion isn&apos;t the entire result we want; this recursive function has to be a helper function to the user-visible one that prepends 1 to this result.</comment></scripts></block-definition><block-definition s="Pascal %&apos;row&apos; %&apos;col&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doIfElse"><block s="reportVariadicOr"><list><block s="reportVariadicEquals"><list><block var="col"/><l>0</l></list></block><block s="reportVariadicEquals"><list><block var="col"/><block var="row"/></list></block></list></block><script><block s="doReport"><l>1</l></block></script><script><block s="doReport"><block s="reportVariadicSum"><list><custom-block s="Pascal %n %n"><block s="reportDifference"><block var="row"/><l>1</l></block><block s="reportDifference"><block var="col"/><l>1</l></block></custom-block><custom-block s="Pascal %n %n"><block s="reportDifference"><block var="row"/><l>1</l></block><block var="col"/></custom-block></list></block></block></script></block></script><scripts><comment x="22" y="184.79999999999998" w="379.3333333333333" collapsed="false">Instead of the OR block in the base case, it&apos;s fine to have two IFs, both reporting 1.</comment></scripts></block-definition><block-definition s="Pascal row %&apos;number&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doIfElse"><block s="reportVariadicEquals"><list><block var="number"/><l>1</l></list></block><script><block s="doReport"><block s="reportNewList"><list><l>1</l><l>1</l></list></block></block></script><script><block s="doReport"><custom-block s="next row %l"><custom-block s="Pascal row %n"><block s="reportDifference"><block var="number"/><l>1</l></block></custom-block></custom-block></block></script></block></script></block-definition><block-definition s="Pascal %&apos;row&apos; %&apos;col&apos; using Pascal-row" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doReport"><block s="reportListItem"><block s="reportVariadicSum"><list><block var="col"/><l>1</l></list></block><custom-block s="Pascal row %n"><block var="row"/></custom-block></block></block></script></block-definition><block-definition s="memoized Pascal %&apos;row&apos; %&apos;col&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doIfElse"><block s="reportVariadicOr"><list><block s="reportVariadicEquals"><list><block var="col"/><l>0</l></list></block><block s="reportVariadicEquals"><list><block var="col"/><block var="row"/></list><comment w="210.66666666666666" collapsed="false">This solution does not store base case values in its memory.  The base case test comes before we look at memory.  It could be done the other way, but this will be faster and easier.</comment></block></list></block><script><block s="doReport"><l>1</l></block></script><script><block s="doIfElse"><block s="reportIsA"><block s="reportListItem"><block var="row"/><block var="Pascal list"/></block><l><option>list</option></l></block><script><block s="doIf"><block s="reportVariadicGreaterThan"><list><block s="reportListItem"><block var="col"/><block s="reportListItem"><block var="row"/><block var="Pascal list"/></block></block><l>0</l></list></block><script><block s="doReport"><block s="reportListItem"><block var="col"/><block s="reportListItem"><block var="row"/><block var="Pascal list"/></block></block></block></script><list></list><comment w="225.3333333333334" collapsed="false">If we already have the desired row and column in the list, report the value stored there.</comment></block></script><script><block s="doReplaceInList"><block var="row"/><block var="Pascal list"/><block s="reportNewList"><list></list></block><comment w="264.6666666666667" collapsed="false">If this is the first value to be computed on this row, we have to put a new list for this row in the overall memory list.</comment></block></script></block></script></block><block s="doDeclareVariables"><list><l>value</l></list></block><block s="doSetVar"><l>value</l><block s="reportVariadicSum"><list><custom-block s="memoized Pascal %n %n"><block s="reportDifference"><block var="row"/><l>1</l></block><block s="reportDifference"><block var="col"/><l>1</l></block></custom-block><custom-block s="memoized Pascal %n %n"><block s="reportDifference"><block var="row"/><l>1</l></block><block var="col"/></custom-block></list><comment w="164" collapsed="false">Here we compute the desired value as usual.  It&apos;s important that the recursive call is to the memoized version of Pascal!  Otherwise there won&apos;t be any saving of time.</comment></block></block><block s="doReplaceInList"><block var="col"/><block s="reportListItem"><block var="row"/><block var="Pascal list"/></block><block var="value"/></block><block s="doReport"><block var="value"/><comment w="276" collapsed="true">We put the value in PASCAL LIST and then report it.</comment></block></script><scripts><comment x="9.333333333333334" y="426.1333333333334" w="567.3333333333334" collapsed="false">There are many subtleties here.  One is the decision to make PASCAL LIST a list of lists  Another is that the choice not to record base cases in PASCAL LIST means that in PASCAL LIST there is no column 0, so item COL of a row list represents column COL.  (Look back at PASCAL USING PASCAL-ROW tor a case in which column COL is item COL+1 of the row.)  Another point is about a peculiarity of Snap! (and Scratch) lists: If you have an empty list and say INSERT something AT 5 OF the list, the value &quot;something&quot; is added as item 1 of the list; INSERT does not create empty items 1 to 4.  But if you say REPLACE ITEM 5 OF the list WITH something, then you do get four empty items followed by the one you specify.  That&apos;s why this code has to use REPLACE even though in every case we are creating a new item, not really replacing an existing one.</comment></scripts></block-definition><block-definition s="Pascal %&apos;row&apos; %&apos;col&apos; (closed form)" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doReport"><block s="reportQuotient"><custom-block s="%n !"><block var="row"/></custom-block><block s="reportVariadicProduct"><list><custom-block s="%n !"><block var="col"/></custom-block><custom-block s="%n !"><block s="reportDifference"><block var="row"/><block var="col"/></block></custom-block></list></block></block></block></script></block-definition><block-definition s="decimal-&gt;binary %&apos;number&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doIfElse"><block s="reportVariadicLessThan"><list><block var="number"/><l>2</l></list></block><script><block s="doReport"><block var="number"/></block></script><script><block s="doReport"><block s="reportJoinWords"><list><custom-block s="decimal-&gt;binary %n"><block s="reportMonadic"><l><option>floor</option></l><block s="reportQuotient"><block var="number"/><l>2</l></block></block></custom-block><block s="reportModulus"><block var="number"/><l>2</l></block></list></block></block></script></block></script><scripts><comment x="16.666666666666668" y="194.79999999999998" w="434.6666666666667" collapsed="false">Two little things that may confuse students:  (1) The recursive call is the left input to JOIN, not the riight input as is more common in recursive functions.  (2)  The use of FLOOR for integer division.&#xD;&#xD;But the big confusing thing has to do with the domain and range of this function -- the data types of the input and the reported value.  The input is a number; the reported value is a text string.  Why the asymmetry?  Snap!, like most programming languages, reads and displays numbers in base 10 ordinarily.  But the input to the block is conceptually a number, which doesn&apos;t have a base; only numerals, the representations of numbers, can have a base.,  So we use numeric operators, &lt; and floor and / and mod, to manipulate the input.  But if we were reporting a number, we wouldn&apos;t have to do anything to it at all!  It&apos;s the same number no matter what base we show it in.  We are reporting a text string, namely a string of digits (zeros and ones since it&apos;s binary we&apos;re reporting).  That&apos;s why we use the text operator JOIN to assemble the reported value.&#xD;&#xD;In the base case this distinction between text and numbers is finessed.  We use &lt;, a numeric operator, for the base case test.  But then we report the 0 or 1, taking advantage of the fact that Snap! will automatically treat the number as a text string when we use it with a text operator such as JOIN.  We get away with this only because in the base case NUMBER is a single digit.  If it were bigger, then JOIN would use the number&apos;s /decimal/ representation as the character string.</comment></scripts></block-definition><block-definition s="base7 %&apos;number&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doIfElse"><block s="reportVariadicLessThan"><list><block var="number"/><l>7</l></list></block><script><block s="doReport"><block var="number"/></block></script><script><block s="doReport"><block s="reportJoinWords"><list><custom-block s="base7 %n"><block s="reportMonadic"><l><option>floor</option></l><block s="reportQuotient"><block var="number"/><l>7</l></block></block></custom-block><block s="reportModulus"><block var="number"/><l>7</l></block></list></block></block></script></block></script></block-definition><block-definition s="%&apos;number&apos; base %&apos;base&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doIfElse"><block s="reportVariadicLessThan"><list><block var="number"/><block var="base"/></list></block><script><block s="doReport"><block var="number"/></block></script><script><block s="doReport"><block s="reportJoinWords"><list><custom-block s="%n base %n"><block s="reportMonadic"><l><option>floor</option></l><block s="reportQuotient"><block var="number"/><block var="base"/></block></block><block var="base"/></custom-block><block s="reportModulus"><block var="number"/><block var="base"/></block></list></block></block></script></block></script></block-definition><block-definition s="%&apos;numeral&apos; from base %&apos;base&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%txt"></input><input type="%n"></input></inputs><script><block s="doIfElse"><block s="reportVariadicEquals"><list><block s="reportTextAttribute"><l><option>length</option></l><block var="numeral"/></block><l>1</l></list><comment w="366" collapsed="false">Students are more likely to use NUMERAL&lt;BASE as the base case test.  That will work, but the test condition really is &quot;Is this a single-digit numeral?&quot;</comment></block><script><block s="doReport"><block var="numeral"/></block></script><script><block s="doReport"><block s="reportVariadicSum"><list><block s="reportVariadicProduct"><list><block var="base"/><custom-block s="%txt from base %n"><custom-block s="all but last letter of %txt"><block var="numeral"/></custom-block><block var="base"/></custom-block></list></block><custom-block s="last letter of %txt"><block var="numeral"/></custom-block></list></block></block></script></block></script><scripts><comment x="16" y="199.46666666666667" w="442" collapsed="false">Again, the confusing part of this problem is keeping straight the domain and range of the function we&apos;re trying to implement.  The domain is numerals, i.e., text strings.  The range is numbers. Thus we use text operators on NUMERAL, including testing its LENGTH in the base case test.  (The operators LAST LETTER OF and ALL BUT LAST LETTER OF are in the word/sentence library.)  But we use × and + to compute the return value, which is a number.  (Point out to students that nowhere in the code for these two pages do we make any reference to the number ten, whereas we did use two and seven, the bases of numerals, earlier.)</comment></scripts></block-definition><block-definition s="all but first letter of %&apos;string&apos;" type="reporter" category="operators"><comment x="0" y="0" w="199" collapsed="false">Takes a text string as input, and reports a new text string containing all but the first character of the input.</comment><header></header><code></code><translations></translations><inputs><input type="%txt"></input></inputs><script><block s="doDeclareVariables"><list><l>result</l><l>i</l></list></block><block s="doWarp"><script><block s="doIf"><block s="reportVariadicEquals"><list><block s="reportTextAttribute"><l><option>length</option></l><block var="string"/></block><l>0</l></list></block><script><block s="doReport"><block s="reportListItem"><l>1</l><block s="reportVariadicSum"><list><l>0</l><l>0</l></list></block></block></block></script><list></list></block><block s="doSetVar"><l>result</l><l></l></block><block s="doSetVar"><l>i</l><l>2</l></block><block s="doUntil"><block s="reportVariadicGreaterThan"><list><block var="i"/><block s="reportTextAttribute"><l><option>length</option></l><block var="string"/></block></list></block><script><block s="doSetVar"><l>result</l><block s="reportJoinWords"><list><block var="result"/><block s="reportLetter"><block var="i"/><block var="string"/></block></list></block></block><block s="doChangeVar"><l>i</l><l>1</l></block></script></block><block s="doReport"><block var="result"/></block></script></block></script></block-definition><block-definition s="all but first word of %&apos;sentence&apos;" type="reporter" category="operators"><comment x="0" y="0" w="223.00000100000003" collapsed="false">Takes a text string as input, divides it into words treating one or more spaces as a word separator (only spaces count; punctuation is part of the word) and reports a text string containing all but the first word, with one space between words and no spaces at the beginning or end. (Note: consider using SENTENCE-&gt;LIST and processing the resulting list instead of doing recursion on sentences in text string form.  List operations are faster.)</comment><header></header><code></code><translations></translations><inputs><input type="%txt"></input></inputs><script><block s="doDeclareVariables"><list><l>index</l><l>bf</l></list></block><block s="doWarp"><script><block s="doSetVar"><l>bf</l><l></l></block><block s="doSetVar"><l>index</l><l>1</l></block><block s="doIf"><block s="reportVariadicEquals"><list><block s="reportTextAttribute"><l><option>length</option></l><block var="sentence"/></block><l>0</l></list></block><script><block s="doReport"><block s="reportListItem"><l>1</l><block s="reportJoinWords"><list><l>empty </l><l>sentence</l></list></block></block></block></script><list></list></block><block s="doUntil"><block s="reportVariadicOr"><list><block s="reportVariadicEquals"><list><block var="index"/><block s="reportTextAttribute"><l><option>length</option></l><block var="sentence"/></block></list></block><block s="reportNot"><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block></block></list></block><script><block s="doChangeVar"><l>index</l><l>1</l></block></script></block><block s="doIf"><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block><script><block s="doReport"><block s="reportListItem"><l>1</l><block s="reportJoinWords"><list><l>empty </l><l>sentence</l></list></block></block></block></script><list></list></block><block s="doUntil"><block s="reportVariadicOr"><list><block s="reportVariadicEquals"><list><block var="index"/><block s="reportTextAttribute"><l><option>length</option></l><block var="sentence"/></block></list></block><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block></list></block><script><block s="doChangeVar"><l>index</l><l>1</l></block></script></block><block s="doIf"><block s="reportVariadicEquals"><list><block var="index"/><block s="reportTextAttribute"><l><option>length</option></l><block var="sentence"/></block></list></block><script><block s="doReport"><l></l></block></script><list></list></block><block s="doUntil"><block s="reportVariadicOr"><list><block s="reportVariadicEquals"><list><block var="index"/><block s="reportTextAttribute"><l><option>length</option></l><block var="sentence"/></block></list></block><block s="reportNot"><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block></block></list></block><script><block s="doChangeVar"><l>index</l><l>1</l></block></script></block><block s="doIf"><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block><script><block s="doReport"><l></l></block></script><list></list></block><block s="doUntil"><block s="reportVariadicGreaterThan"><list><block var="index"/><block s="reportTextAttribute"><l><option>length</option></l><block var="sentence"/></block></list></block><script><block s="doSetVar"><l>bf</l><block s="reportJoinWords"><list><block var="bf"/><block s="reportLetter"><block var="index"/><block var="sentence"/></block></list></block></block><block s="doChangeVar"><l>index</l><l>1</l></block></script></block><block s="doReport"><block var="bf"/></block></script></block></script></block-definition><block-definition s="all but last letter of %&apos;string&apos;" type="reporter" category="operators"><comment x="0" y="0" w="217.99999999999997" collapsed="false">Takes a text string as input, and reports a new text string containing all but the last letter of the input.</comment><header></header><code></code><translations></translations><inputs><input type="%txt"></input></inputs><script><block s="doDeclareVariables"><list><l>result</l><l>i</l></list></block><block s="doWarp"><script><block s="doIf"><block s="reportVariadicEquals"><list><block s="reportTextAttribute"><l><option>length</option></l><block var="string"/></block><l>0</l></list></block><script><block s="doReport"><block s="reportListItem"><l>1</l><block s="reportVariadicSum"><list><l>0</l><l>0</l></list></block></block></block></script><list></list></block><block s="doSetVar"><l>result</l><l></l></block><block s="doSetVar"><l>i</l><l>1</l></block><block s="doUntil"><block s="reportVariadicEquals"><list><block var="i"/><block s="reportTextAttribute"><l><option>length</option></l><block var="string"/></block></list></block><script><block s="doSetVar"><l>result</l><block s="reportJoinWords"><list><block var="result"/><block s="reportLetter"><block var="i"/><block var="string"/></block></list></block></block><block s="doChangeVar"><l>i</l><l>1</l></block></script></block><block s="doReport"><block var="result"/></block></script></block></script></block-definition><block-definition s="all but last word of %&apos;sentence&apos;" type="reporter" category="operators"><comment x="0" y="0" w="212" collapsed="false">Takes a text string as input, divides it into words treating one or more spaces as a word separator (only spaces count; punctuation is part of the word) and reports a text string containing all but the last word, with one space between words and no spaces at the beginning or end.  (Note: consider using SENTENCE-&gt;LIST and processing the resulting list instead of doing recursion on sentences in text string form.  List operations are faster.)</comment><header></header><code></code><translations></translations><inputs><input type="%txt"></input></inputs><script><block s="doDeclareVariables"><list><l>index</l><l>bl</l></list></block><block s="doWarp"><script><block s="doSetVar"><l>bl</l><l></l></block><block s="doSetVar"><l>index</l><block s="reportTextAttribute"><l><option>length</option></l><block var="sentence"/></block></block><block s="doIf"><block s="reportVariadicEquals"><list><block s="reportTextAttribute"><l><option>length</option></l><block var="sentence"/></block><l>0</l></list></block><script><block s="doReport"><block s="reportListItem"><l>1</l><block s="reportJoinWords"><list><l>empty </l><l>sentence</l></list></block></block></block></script><list></list></block><block s="doUntil"><block s="reportVariadicOr"><list><block s="reportVariadicEquals"><list><block var="index"/><l>1</l></list></block><block s="reportNot"><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block></block></list></block><script><block s="doChangeVar"><l>index</l><l>-1</l></block></script></block><block s="doIf"><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block><script><block s="doReport"><block s="reportListItem"><l>1</l><block s="reportJoinWords"><list><l>empty </l><l>sentence</l></list></block></block></block></script><list></list></block><block s="doUntil"><block s="reportVariadicOr"><list><block s="reportVariadicEquals"><list><block var="index"/><l>1</l></list></block><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block></list></block><script><block s="doChangeVar"><l>index</l><l>-1</l></block></script></block><block s="doIf"><block s="reportVariadicEquals"><list><block var="index"/><l>1</l></list></block><script><block s="doReport"><l></l></block></script><list></list></block><block s="doUntil"><block s="reportVariadicOr"><list><block s="reportVariadicEquals"><list><block var="index"/><l>1</l></list></block><block s="reportNot"><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block></block></list></block><script><block s="doChangeVar"><l>index</l><l>-1</l></block></script></block><block s="doIf"><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block><script><block s="doReport"><l></l></block></script><list></list></block><block s="doUntil"><block s="reportVariadicLessThan"><list><block var="index"/><l>1</l></list></block><script><block s="doSetVar"><l>bl</l><block s="reportJoinWords"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><block var="bl"/></list></block></block><block s="doChangeVar"><l>index</l><l>-1</l></block></script></block><block s="doReport"><block var="bl"/></block></script></block></script></block-definition><block-definition s="first word of %&apos;sentence&apos;" type="reporter" category="operators"><comment x="0" y="0" w="236" collapsed="false">Takes a text string as input, divides it into words treating one or more spaces as a word separator (only spaces count; punctuation is part of the word) and reports a text string containing only the first word, with no spaces before or after it.</comment><header></header><code></code><translations></translations><inputs><input type="%txt"></input></inputs><script><block s="doDeclareVariables"><list><l>index</l><l>first</l></list></block><block s="doWarp"><script><block s="doSetVar"><l>first</l><l></l></block><block s="doSetVar"><l>index</l><l>1</l></block><block s="doIf"><block s="reportVariadicEquals"><list><block s="reportTextAttribute"><l><option>length</option></l><block var="sentence"/></block><l>0</l></list></block><script><block s="doReport"><block s="reportListItem"><l>1</l><block s="reportJoinWords"><list><l>empty </l><l>sentence</l></list></block></block></block></script><list></list></block><block s="doUntil"><block s="reportVariadicOr"><list><block s="reportVariadicEquals"><list><block var="index"/><block s="reportTextAttribute"><l><option>length</option></l><block var="sentence"/></block></list></block><block s="reportNot"><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block></block></list></block><script><block s="doChangeVar"><l>index</l><l>1</l></block></script></block><block s="doIf"><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block><script><block s="doReport"><block s="reportListItem"><l>1</l><block s="reportJoinWords"><list><l>empty </l><l>sentence</l></list></block></block></block></script><list></list></block><block s="doUntil"><block s="reportVariadicOr"><list><block s="reportVariadicEquals"><list><block var="index"/><block s="reportTextAttribute"><l><option>length</option></l><block var="sentence"/></block></list></block><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block></list></block><script><block s="doSetVar"><l>first</l><block s="reportJoinWords"><list><block var="first"/><block s="reportLetter"><block var="index"/><block var="sentence"/></block></list></block></block><block s="doChangeVar"><l>index</l><l>1</l></block></script></block><block s="doIf"><block s="reportNot"><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block></block><script><block s="doSetVar"><l>first</l><block s="reportJoinWords"><list><block var="first"/><block s="reportLetter"><block var="index"/><block var="sentence"/></block></list></block></block></script><list></list></block><block s="doReport"><block var="first"/></block></script></block></script></block-definition><block-definition s="last letter of %&apos;word&apos;" type="reporter" category="operators"><comment x="0" y="0" w="260" collapsed="false">Takes a text string as input, and reports the last character in the string.</comment><header></header><code></code><translations></translations><inputs><input type="%txt"></input></inputs><script><block s="doReport"><block s="reportLetter"><block s="reportTextAttribute"><l><option>length</option></l><block var="word"/></block><block var="word"/></block></block></script></block-definition><block-definition s="last word of %&apos;sentence&apos;" type="reporter" category="operators"><comment x="0" y="0" w="262" collapsed="false">Takes a text string as input, divides it into words treating one or more spaces as a word separator (only spaces count; punctuation is part of the word) and reports a text string containing only the last word of the input, with no spaces before or after it.</comment><header></header><code></code><translations></translations><inputs><input type="%txt"></input></inputs><script><block s="doDeclareVariables"><list><l>index</l><l>last</l></list></block><block s="doWarp"><script><block s="doSetVar"><l>last</l><l></l></block><block s="doSetVar"><l>index</l><block s="reportTextAttribute"><l><option>length</option></l><block var="sentence"/></block></block><block s="doIf"><block s="reportVariadicEquals"><list><block s="reportTextAttribute"><l><option>length</option></l><block var="sentence"/></block><l>0</l></list></block><script><block s="doReport"><block s="reportListItem"><l>1</l><block s="reportJoinWords"><list><l>empty </l><l>sentence</l></list></block></block></block></script><list></list></block><block s="doUntil"><block s="reportVariadicOr"><list><block s="reportVariadicEquals"><list><block var="index"/><l>1</l></list></block><block s="reportNot"><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block></block></list></block><script><block s="doChangeVar"><l>index</l><l>-1</l></block></script></block><block s="doIf"><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block><script><block s="doReport"><block s="reportListItem"><l>1</l><block s="reportJoinWords"><list><l>empty </l><l>sentence</l></list></block></block></block></script><list></list></block><block s="doUntil"><block s="reportVariadicOr"><list><block s="reportVariadicEquals"><list><block var="index"/><l>1</l></list></block><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block></list></block><script><block s="doSetVar"><l>last</l><block s="reportJoinWords"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><block var="last"/></list></block></block><block s="doChangeVar"><l>index</l><l>-1</l></block></script></block><block s="doIf"><block s="reportNot"><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block></block><script><block s="doSetVar"><l>last</l><block s="reportJoinWords"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><block var="last"/></list></block></block></script><list></list></block><block s="doReport"><block var="last"/></block></script></block></script></block-definition><block-definition s="empty word? %&apos;word&apos;" type="predicate" category="operators"><comment x="0" y="0" w="208" collapsed="false">Takes a text string as input, and reports TRUE if the string has no characters in it of any kind, otherwise false.</comment><header></header><code></code><translations></translations><inputs><input type="%txt"></input></inputs><script><block s="doReport"><block s="reportVariadicEquals"><list><block s="reportTextAttribute"><l><option>length</option></l><block var="word"/></block><l>0</l></list></block></block></script></block-definition><block-definition s="empty sentence? %&apos;sentence&apos;" type="predicate" category="operators"><comment x="0" y="0" w="221" collapsed="false">Takes a text string as input, and reports TRUE if the input contains no characters other than spaces (therefore, no words when the string is considered as a sentence), otherwise FALSE.</comment><header></header><code></code><translations></translations><inputs><input type="%txt"></input></inputs><script><block s="doDeclareVariables"><list><l>index</l></list></block><block s="doSetVar"><l>index</l><l>1</l></block><block s="doIf"><block s="reportVariadicEquals"><list><block s="reportTextAttribute"><l><option>length</option></l><block var="sentence"/></block><l>0</l></list></block><script><block s="doReport"><block s="reportBoolean"><l><bool>true</bool></l></block></block></script><list></list></block><block s="doUntil"><block s="reportVariadicOr"><list><block s="reportVariadicEquals"><list><block var="index"/><block s="reportTextAttribute"><l><option>length</option></l><block var="sentence"/></block></list></block><block s="reportNot"><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block></block></list></block><script><block s="doChangeVar"><l>index</l><l>1</l></block></script></block><block s="doReport"><block s="reportVariadicEquals"><list><block s="reportLetter"><block var="index"/><block var="sentence"/></block><l> </l></list></block></block></script></block-definition><block-definition s="digit-&gt;value %&apos;digit&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doIfElse"><block s="reportVariadicLessThan"><list><block s="reportUnicode"><block var="digit"/></block><block s="reportUnicode"><l>A</l></block></list></block><script><block s="doReport"><block var="digit"/></block></script><script><block s="doIfElse"><block s="reportVariadicLessThan"><list><block s="reportUnicode"><block var="digit"/></block><block s="reportUnicode"><l>a</l></block></list></block><script><block s="doReport"><block s="reportVariadicSum"><list><l>10</l><block s="reportDifference"><block s="reportUnicode"><block var="digit"/></block><block s="reportUnicode"><l>A</l></block></block></list></block></block></script><script><block s="doReport"><block s="reportVariadicSum"><list><l>10</l><block s="reportDifference"><block s="reportUnicode"><block var="digit"/></block><block s="reportUnicode"><l>a</l></block></block></list></block></block></script></block></script></block></script><scripts><comment x="10.666666666666666" y="260.8" w="344.6666666666667" collapsed="false">The input to this block is a digit, which is to say, it&apos;s a *numeral*, a text string, of length 1.  So we are going to use text operators on it.  This algorithm knows that in Unicode, digits 0-9 come before upper case letters A-Z, which come before lower case letters a-z.  (We are not required to handle capital letters, but that&apos;s an obvious improvement to the user interface.)  The first IF test tests whether the digit is one of the decimal digits 0-9.  If so, we can take advantage of the automatic type conversion between decimal numerals and numbers by just reporting the digit.  But we could have followed the pattern of the later cases by using the expression</comment><script x="38.666666666666664" y="402.2666666666667"><block s="reportDifference"><block s="reportUnicode"><block var="digit"/></block><block s="reportUnicode"><l>0</l></block></block></script><comment x="16.666666666666668" y="432.4000000000001" w="344" collapsed="false">Failing that, we test for a capital letter.  If that&apos;s what we have, we subtract the Unicode for A from the Unicode from the given letter, and add that difference to 10 because A represents 10.  Same for lower case letters, but using the Unicode for a instead of the Unicode for A.</comment><comment x="13.333333333333334" y="517.2000000000002" w="349.3333333333333" collapsed="false">Note that there&apos;s nothing advanced about the structure of this block.  It&apos;s not a recursive function, just two nested IF-ELSE tests.  But abstracting away the details about Unicode values will make the recursive functions we&apos;re asked to write much easier.</comment></scripts></block-definition><block-definition s="value-&gt;digit %&apos;value&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%n"></input></inputs><script><block s="doIfElse"><block s="reportVariadicLessThan"><list><block var="value"/><l>10</l></list></block><script><block s="doReport"><block var="value"/></block></script><script><block s="doReport"><block s="reportUnicodeAsLetter"><block s="reportVariadicSum"><list><block s="reportUnicode"><l>a</l></block><block s="reportDifference"><block var="value"/><l>10</l></block></list></block></block></block></script></block></script><scripts><script x="264.3333333333333" y="75.46666666666665"><block s="reportUnicodeAsLetter"><block s="reportVariadicSum"><list><block s="reportUnicode"><l>0</l></block><block var="value"/></list></block></block></script><comment x="6.666666666666667" y="178.13333333333333" w="412.6666666666667" collapsed="false">Again, it&apos;s the issue of domain and range that requires thought here.  The input is a /number/, with a value between 0 and 35 inclusive.  The value to report is a text character, maybe a decimal digit but maybe a letter.</comment></scripts></block-definition><block-definition s="%&apos;number&apos; base %&apos;base&apos; (extended)" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%n"></input></inputs><script><block s="doIfElse"><block s="reportVariadicLessThan"><list><block var="number"/><block var="base"/></list></block><script><block s="doReport"><custom-block s="value-&gt;digit %n"><block var="number"/></custom-block></block></script><script><block s="doReport"><block s="reportJoinWords"><list><custom-block s="%n base %n (extended)"><block s="reportMonadic"><l><option>floor</option></l><block s="reportQuotient"><block var="number"/><block var="base"/></block></block><block var="base"/></custom-block><custom-block s="value-&gt;digit %n"><block s="reportModulus"><block var="number"/><block var="base"/></block></custom-block></list></block></block></script></block></script><scripts><comment x="8.666666666666666" y="197.46666666666667" w="362" collapsed="false">We&apos;re given a number and want a numeral, so we call VALUE-&gt;DIGIT in the two places where we&apos;re expecting a single-digit value: the base case and the rightmost digit of the recursive case.</comment></scripts></block-definition><block-definition s="%&apos;numeral&apos; from base %&apos;base&apos; (extended)" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%txt"></input><input type="%n"></input></inputs><script><block s="doIfElse"><block s="reportVariadicEquals"><list><block s="reportTextAttribute"><l><option>length</option></l><block var="numeral"/><comment w="275.3333333333333" collapsed="false">Note that testing NUMERAL&lt;BASE won&apos;t work if NUMERAL is a letter!</comment></block><l>1</l></list></block><script><block s="doReport"><custom-block s="digit-&gt;value %s"><block var="numeral"/></custom-block></block></script><script><block s="doReport"><block s="reportVariadicSum"><list><block s="reportVariadicProduct"><list><block var="base"/><custom-block s="%txt from base %n (extended)"><custom-block s="all but last letter of %txt"><block var="numeral"/></custom-block><block var="base"/></custom-block></list></block><custom-block s="digit-&gt;value %s"><custom-block s="last letter of %txt"><block var="numeral"/></custom-block></custom-block></list></block></block></script></block></script></block-definition><block-definition s="two-scoop bowls %&apos;flavor list&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIfElse"><block s="reportVariadicLessThan"><list><block s="reportListAttribute"><l><option>length</option></l><block var="flavor list"/></block><l>2</l></list></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><script><block s="doReport"><custom-block s="append %mult%l"><list><custom-block s="map %repRing over %mult%l"><block s="reifyReporter"><autolambda><block s="reportNewList"><list><block s="reportListItem"><l>1</l><block var="flavor list"/></block><l></l></list></block></autolambda><list></list></block><list><block s="reportCDR"><block var="flavor list"/></block></list></custom-block><custom-block s="two-scoop bowls %l"><block s="reportCDR"><block var="flavor list"/></block></custom-block></list></custom-block></block></script></block></script><scripts><comment x="16.666666666666668" y="227.46666666666667" w="394.6666666666667" collapsed="false">At first I called the input &quot;flavors,&quot; the same name as the global variable with the eight flavors on the menu.  I decided it would be pedagogically clearer to use a different name, but if I were writing this for my own use I&apos;d have kept the same name for both.  Students should understand that Snap! wouldn&apos;t be confused by that; within this definition, the local variable takes precedence over the global one.&#xD;&#xD;If students are confused about the different list combiners, it might be worth demonstrating (or have students experiment with and document) how the result is different if you use LIST or IN FRONT OF instead of APPEND.&#xD;&#xD;Note that there&apos;s nothing wrong with using a HOF (MAP) to do the part of the problem in which you list the combinations that include the first flavor, even though we&apos;re using recursion to deal with the rest of the flavors.</comment></scripts></block-definition><block-definition s="three-scoop bowls %&apos;flavor list&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIfElse"><block s="reportVariadicLessThan"><list><block s="reportListAttribute"><l><option>length</option></l><block var="flavor list"/></block><l>3</l></list></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><script><block s="doReport"><custom-block s="append %mult%l"><list><custom-block s="map %repRing over %mult%l"><block s="reifyReporter"><autolambda><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="flavor list"/></block><l/></block></autolambda><list></list></block><list><custom-block s="two-scoop bowls %l"><block s="reportCDR"><block var="flavor list"/></block></custom-block></list></custom-block><custom-block s="three-scoop bowls %l"><block s="reportCDR"><block var="flavor list"/></block></custom-block></list></custom-block></block></script></block></script><scripts><comment x="15.333333333333334" y="233.4666666666666" w="416.6666666666667" collapsed="false">This may be the hardest exercise, conceptually, in the course.  (Later exercises will use similar techniques, but the first time is the hardest.)  There&apos;s a big hint in the white-background sentence between the two green boxes on the page:  You can use TWO-SCOOP BOWLS as a helper function for this one!&#xD;&#xD;Compare this definition with that of TWO-SCOOP BOWLS.  There are three differences, two of which are trivial (but easy to forget and painful to debug):&#xD;&#xD;1.  We can&apos;t make a three-scoop bowl unless there are at least three flavors in the flavor list, so the base case test changes from length&lt;2 to length&lt;3.&#xD;&#xD;2.  The recursive call has to be THREE-SCOOP BOWLS!&#xD;&#xD;The complicated change is in the MAP.  In the two-scoop case, what we want to do with the first flavor is make a two-item list of {first flavor, []} filling the box with one flavor at a time from the all-but-first of the flavor list.  In this case, with what do we want to combine the first flavor? We don&apos;t want to make a list such as {chocolate pudding, pumpkin}; we want to make lists such as {chocolate pudding, PUMPKIN, RUM RAISIN}.  Here&apos;s the key insight:  The part in capital letters is a two-scoop bowl!  So instead of MAP ... OVER (ALL BUT FIRST OF (FLAVOR LIST)), we want MAP ... OVER (TWO-SCOOP BOWLS ...).  Having made that change, we also have to change the combining function that&apos;s the first input to MAP.  If it were LIST, we&apos;d get {chocolate pudding, {pumpkin, rum raisin}} -- a list of length 2 in which the second item is a list.  But we want a list of length 3, so we have to put the first flavor IN FRONT OF the two-scoop bowl.&#xD;&#xD;Few if any students will succeed at inventing this.  But try to ensure that most of them end up understanding it once they see it.  You&apos;ll be able to tell because if they understand this, they can succeed at the SUBSETS problem on the next page.  And then they&apos;re ready for anything!  They&apos;ll know more about computer science than many working programmers.</comment></scripts></block-definition><block-definition s="bowls of %&apos;howmany&apos; scoops from menu %&apos;flavor list&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportVariadicEquals"><list><block var="howmany"/><l>0</l></list></block><script><block s="doReport"><block s="reportNewList"><list><block s="reportNewList"><list></list></block></list></block></block></script><list></list></block><block s="doIf"><block s="reportVariadicLessThan"><list><block s="reportListAttribute"><l><option>length</option></l><block var="flavor list"/></block><block var="howmany"/></list></block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><list></list></block><block s="doReport"><custom-block s="append %mult%l"><list><custom-block s="map %repRing over %mult%l"><block s="reifyReporter"><autolambda><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="flavor list"/></block><l/></block></autolambda><list></list></block><list><custom-block s="bowls of %n scoops from menu %l"><block s="reportDifference"><block var="howmany"/><l>1</l></block><block s="reportCDR"><block var="flavor list"/></block></custom-block></list></custom-block><custom-block s="bowls of %n scoops from menu %l"><block var="howmany"/><block s="reportCDR"><block var="flavor list"/></block></custom-block></list></custom-block></block></script><scripts><comment x="9.333333333333334" y="314.8" w="465.3333333333333" collapsed="false">This would be an impossible problem if the students hadn&apos;t done the two-scoop and three-scoop versions first.  But in fact it&apos;s not that hard with THREE-SCOOP BOWLS as a starting point.  The same three places have to be changed as in the move from two scoops to three:&#xD;&#xD;1.  The existing base case test requires at least HOWMANY flavors in the menu to be able to make a bowl.  But -- the only real difficulty here -- there is /another/ base case that&apos;s easy to forget:  What if we are asked to make a zero-scoop bowl?  This /will/ happen because of a recursive call.  (Now that there are three different cases altogether, two base cases and the recursive case, I&apos;ve chosen to take advantage of the fact that REPORT ends the block to use separate IFs rather than nested IF-ELSEs.)  The really tricky thing is that if HOWMANY=0 it&apos;s not an empty list we report.  If there are fewer flavors in the list than we need to satisfy the requirement for HOWMANY scoops in a bowl, then the problem is impossible; there are no bowls satisfying the requirements.  But if we are asked for a zero-scoop bowl, that isn&apos;t impossible.  There&apos;s exactly one bowl satisfying the request, namely, the empty bowl.  So we report a list containing an empty bowl, not an empty list.&#xD;&#xD;2.  The recursive call has to be to this procedure (and with two inputs).&#xD;&#xD;3.  The MAP has to map over something different, although it turns out that the function input to MAP doesn&apos;t change from the three-scoop version.  What list do we map over?  That is, with what do we want to combine the first flavor?  Answer: a bowl of HOWMANY-1 flavors!  So this, too, has to be a recursive call.  Remind students how TREE3 calls TREE2, but the recursive TREE calls itself with one smaller level; this is the same idea.&#xD;&#xD;Take a moment to ask students to appreciate what a simple procedure this is, given the complicated problem it solves.  That&apos;s the power of recursion.</comment></scripts></block-definition><block-definition s="bowls of %&apos;howmany&apos; scoops from menu %&apos;flavor list&apos; with duplicates allowed" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%n"></input><input type="%l"></input></inputs><script><block s="doIf"><block s="reportVariadicEquals"><list><block var="howmany"/><l>0</l></list></block><script><block s="doReport"><block s="reportNewList"><list><block s="reportNewList"><list></list></block></list></block></block></script><list></list></block><block s="doIf"><custom-block s="empty? %l"><block var="flavor list"/></custom-block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><list></list></block><block s="doReport"><custom-block s="append %mult%l"><list><custom-block s="map %repRing over %mult%l"><block s="reifyReporter"><autolambda><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="flavor list"/></block><l/></block></autolambda><list></list></block><list><custom-block s="bowls of %n scoops from menu %l with duplicates allowed"><block s="reportDifference"><block var="howmany"/><l>1</l></block><block var="flavor list"/></custom-block></list></custom-block><custom-block s="bowls of %n scoops from menu %l with duplicates allowed"><block var="howmany"/><block s="reportCDR"><block var="flavor list"/></block></custom-block></list></custom-block></block></script><scripts><comment x="6.666666666666667" y="368.8" w="467.3333333333333" collapsed="false">Okay, I admit, I had trouble debugging this one.&#xD;&#xD;The trouble (for me anyway) is in the second base case.  With duplicates allowed, it&apos;s no longer true that we need N flavors in the menu to make an N-scoop bowl.  One flavor is enough!  So instead of comparing the length of the menu with HOWMANY, we just make sure it isn&apos;t empty.&#xD;&#xD;The only other change (aside from making the recursive calls to the correct block) is that in the first recursive call, we find HOWMANY-1 scoops *from the same menu*, rather than from the menu with the first flavor removed.&#xD;&#xD;As students are working on this, remind them that vanilla-chocolate is still the same bowl as chocolate-vanilla, and only one of those should be included in the list.  Saying it another way, we now allow duplicate flavors within a bowl, but not duplicate bowls.&#xD;&#xD;This procedure demonstrates a common programming idiom:  It has two inputs, and it makes two recursive calls, one in which the first input gets smaller and the second is the same, and one in which the first input stays the same and the second one gets smaller.</comment></scripts></block-definition><block-definition s="subsets %&apos;set&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIf"><custom-block s="empty? %l"><block var="set"/></custom-block><script><block s="doReport"><block s="reportNewList"><list><block s="reportNewList"><list></list></block></list></block></block></script><list></list></block><block s="doReport"><custom-block s="append %mult%l"><list><custom-block s="faster subsets %l"><block s="reportCDR"><block var="set"/></block></custom-block><custom-block s="map %repRing over %mult%l"><block s="reifyReporter"><autolambda><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="set"/></block><l/></block></autolambda><list></list></block><list><custom-block s="faster subsets %l"><block s="reportCDR"><block var="set"/></block></custom-block></list></custom-block></list></custom-block></block></script><scripts><comment x="6.666666666666667" y="206.13333333333333" w="444" collapsed="false">Note:  Because the result of calling this block is a list of lists, Snap! displays it in table view, but because the first item is an empty list, what you see is a table with no columns.  To fix this, right-click on the speech balloon and choose &quot;List view.&quot;  Then drag out the resize handle in the bottom right corner.&#xD;&#xD;Isn&apos;r this elegant?  It&apos;s hardly any code at all!&#xD;&#xD;This code is quite similar to, but /simpler/ than, the one for bowls of ice cream.  Removing the restriction to subsets of a fixed size means that there&apos;s no HOWMANY to manipulate.  In fact, some students may write SUBSETS by calling BOWLS for every possible size and appending the results:</comment><script x="10" y="365.6666666666667"><block s="doDeclareVariables"><list><l>result</l></list></block><block s="doSetVar"><l>result</l><block s="reportNewList"><list></list></block></block><custom-block s="for %upvar = %n to %n %cs"><l>i</l><l>0</l><block s="reportListAttribute"><l><option>length</option></l><block var="set"/></block><script><block s="doSetVar"><l>result</l><custom-block s="append %mult%l"><list><block var="result"/><custom-block s="bowls of %n scoops from menu %l"><block var="i"/><block var="set"/></custom-block></list></custom-block></block></script></custom-block><block s="doReport"><block var="result"/></block></script><comment x="8.666666666666666" y="507.4666666666667" w="437.3333333333333" collapsed="false">This works, and it&apos;s a smart application of the idea of using the tools you have rather than starting over.  But my version above is elegant in a different way.  Instead of dividing the problem into N separate parts, where N is the size of the set, my version divides it into just two parts: the subsets that include the first element (Pretzel, in the example) and the subsets that don&apos;t include it.</comment></scripts></block-definition><block-definition s="faster subsets %&apos;set&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIf"><custom-block s="empty? %l"><block var="set"/></custom-block><script><block s="doReport"><block s="reportNewList"><list><block s="reportNewList"><list></list></block></list></block></block></script><list></list></block><block s="doDeclareVariables"><list><l>smaller</l></list></block><block s="doSetVar"><l>smaller</l><custom-block s="subsets %l"><block s="reportCDR"><block var="set"/></block></custom-block></block><block s="doReport"><custom-block s="append %mult%l"><list><block var="smaller"/><custom-block s="map %repRing over %mult%l"><block s="reifyReporter"><autolambda><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="set"/></block><l/></block></autolambda><list></list></block><list><block var="smaller"/></list></custom-block></list></custom-block></block></script><scripts><comment x="8" y="233.4666666666666" w="451.33333333333326" collapsed="false">Since the first input to APPEND in SUBSETS depends on the second -- each subset that includes Pretzel is based on a subset that doesn&apos;t include it -- I used a script variable to hold the result of the recursive call.  This is a very important optimization; if you make two recursive calls instead, the program takes much longer, O(2^2n) instead of O(2^n).  (Unlike the structurally similar Pascal&apos;s Triangle problem, we can&apos;t get this below O(2^n) because there are 2^n subsets, and we have to construct each of them somehow.)  So this problem is inherently intractable for large sets.</comment></scripts></block-definition><block-definition s="squares %&apos;numbers&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIfElse"><custom-block s="empty? %l"><block var="numbers"/></custom-block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><script><block s="doReport"><block s="reportCONS"><block s="reportVariadicProduct"><list><block s="reportListItem"><l>1</l><block var="numbers"/></block><block s="reportListItem"><l>1</l><block var="numbers"/></block></list></block><custom-block s="squares %l"><block s="reportCDR"><block var="numbers"/></block></custom-block></block></block></script></block></script><scripts><comment x="11.333333333333334" y="192.79999999999998" w="445.3333333333333" collapsed="false">As the hint suggests, this is identical to PLURALS except for the expression in the first input to IN FRONT OF, which computes the spuare instead of the plural of ITEM 1 OF the input.</comment></scripts></block-definition><block-definition s="exaggerate %&apos;sentence&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%txt"></input></inputs><script><block s="doReport"><custom-block s="list $arrowRight sentence %l"><custom-block s="exaggerate wordlist %l"><custom-block s="sentence $arrowRight list %txt"><block var="sentence"/></custom-block></custom-block></custom-block></block></script></block-definition><block-definition s="exaggerate wordlist %&apos;words&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIfElse"><custom-block s="empty? %l"><block var="words"/></custom-block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><script><block s="doReport"><block s="reportCONS"><custom-block s="exaggerate word %s"><block s="reportListItem"><l>1</l><block var="words"/></block></custom-block><custom-block s="exaggerate wordlist %l"><block s="reportCDR"><block var="words"/></block></custom-block></block></block></script></block></script><scripts><comment x="9.333333333333334" y="198.79999999999998" w="371.3333333333333" collapsed="false">This part is the same as PLURALS or SQUARES.</comment></scripts></block-definition><block-definition s="exaggerate word %&apos;word&apos;" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%s"></input></inputs><script><block s="doIf"><block s="reportIsA"><block var="word"/><l><option>number</option></l></block><script><block s="doReport"><block s="reportVariadicProduct"><list><l>2</l><block var="word"/></list></block></block></script><list></list></block><block s="doIf"><block s="reportVariadicEquals"><list><block var="word"/><l>good</l></list></block><script><block s="doReport"><l>great</l></block></script><list></list></block><block s="doIf"><block s="reportVariadicEquals"><list><block var="word"/><l>bad</l></list></block><script><block s="doReport"><l>terrible</l></block></script><list></list></block><block s="doIf"><block s="reportVariadicEquals"><list><block var="word"/><l>like</l></list></block><script><block s="doReport"><l>love</l></block></script><list></list></block><block s="doIf"><block s="reportVariadicEquals"><list><block var="word"/><l>dislike</l></list></block><script><block s="doReport"><l>hate</l></block></script><list></list></block><block s="doReport"><block var="word"/></block></script></block-definition><block-definition s="exaggerate %&apos;sentence&apos; using MAP" type="reporter" category="operators"><header></header><code></code><translations></translations><inputs><input type="%txt"></input></inputs><script><block s="doReport"><custom-block s="list $arrowRight sentence %l"><custom-block s="map %repRing over %mult%l"><block s="reifyReporter"><autolambda><custom-block s="exaggerate word %s"><l></l></custom-block></autolambda><list></list></block><list><custom-block s="sentence $arrowRight list %txt"><block var="sentence"/></custom-block></list></custom-block></custom-block></block></script><scripts><comment x="10.666666666666666" y="119.46666666666665" w="404" collapsed="false">This version doesn&apos;t need EXAGGERATE WORDLIST, which is replaced by the call to MAP.  It does still use EXAGGERATE WORD, which is the function input to MAP.</comment></scripts></block-definition><block-definition s="pairup %&apos;words&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIfElse"><custom-block s="empty? %l"><block s="reportCDR"><block var="words"/></block></custom-block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><script><block s="doReport"><block s="reportCONS"><block s="reportJoinWords"><list><block s="reportListItem"><l>1</l><block var="words"/></block><block s="reportListItem"><l>2</l><block var="words"/></block></list></block><custom-block s="pairup %l"><block s="reportCDR"><block var="words"/></block></custom-block></block></block></script></block></script><scripts><comment x="10.666666666666666" y="194.79999999999998" w="440" collapsed="false">You can&apos;t just mechanically copy ODD NUMBERED ITEMS here.  This code is similar in that it has a one-item list as its base case (calling PAIRUP with an empty list is an uncaught error), but it&apos;s different in that we don&apos;t skip over any items; each word except the last gets to be the front half of a combined word.</comment></scripts></block-definition><block-definition s="ends-e %&apos;words&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIfElse"><custom-block s="empty? %l"><block var="words"/><comment w="90" collapsed="true">Base case</comment></custom-block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><script><block s="doIfElse"><block s="reportVariadicEquals"><list><custom-block s="last letter of %txt"><block s="reportListItem"><l>1</l><block var="words"/></block></custom-block><l>e</l></list><comment w="130" collapsed="true">If first word matches</comment></block><script><block s="doReport"><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="words"/></block><custom-block s="ends-e %l"><block s="reportCDR"><block var="words"/></block></custom-block><comment w="90" collapsed="false">then include it in the result.</comment></block></block></script><script><block s="doReport"><custom-block s="ends-e %l"><block s="reportCDR"><block var="words"/><comment w="133.33333333333334" collapsed="true">Otherwise leave it out.</comment></block></custom-block></block></script></block></script></block></script><scripts><comment x="14.000000000000002" y="264.1333333333333" w="539.3333333333334" collapsed="true">This is exactly the same as EVENS except for the test that&apos;s applied to ITEM 1 OF the input.</comment></scripts></block-definition><block-definition s="numbers %&apos;words&apos;" type="reporter" category="lists"><header></header><code></code><translations></translations><inputs><input type="%l"></input></inputs><script><block s="doIfElse"><custom-block s="empty? %l"><block var="words"/><comment w="90" collapsed="true">Base case</comment></custom-block><script><block s="doReport"><block s="reportNewList"><list></list></block></block></script><script><block s="doIfElse"><block s="reportIsA"><block s="reportListItem"><l>1</l><block var="words"/></block><l><option>number</option></l><comment w="130" collapsed="true">If first word matches</comment></block><script><block s="doReport"><block s="reportCONS"><block s="reportListItem"><l>1</l><block var="words"/></block><custom-block s="ends-e %l"><block s="reportCDR"><block var="words"/></block></custom-block><comment w="90" collapsed="false">then include it in the result.</comment></block></block></script><script><block s="doReport"><custom-block s="ends-e %l"><block s="reportCDR"><block var="words"/><comment w="133.33333333333334" collapsed="true">Otherwise leave it out.</comment></block></custom-block></block></script></block></script></block></script><scripts><comment x="11.333333333333334" y="274.1333333333333" w="539.3333333333334" collapsed="true">This is exactly the same as EVENS and ENDS-E except for the test that&apos;s applied to ITEM 1 OF the input.</comment></scripts></block-definition></blocks><stage name="Stage" width="480" height="360" costume="0" color="255,255,255,1" tempo="60" threadsafe="false" penlog="false" volume="100" pan="0" lines="round" ternary="true" hyperops="true" codify="false" inheritance="false" sublistIDs="false" id="3965"><pentrails>data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeAAAAFoCAYAAACPNyggAAAAAXNSR0IArs4c6QAADoVJREFUeF7t1cEJAAAIxDDdf2m3sJ+4wEEQuuMIECBAgACBd4F9XzRIgAABAgQIjAB7AgIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECAiwHyBAgAABAoGAAAfoJgkQIECAgAD7AQIECBAgEAgIcIBukgABAgQICLAfIECAAAECgYAAB+gmCRAgQICAAPsBAgQIECAQCAhwgG6SAAECBAgIsB8gQIAAAQKBgAAH6CYJECBAgIAA+wECBAgQIBAICHCAbpIAAQIECByxcQFpoRMBzwAAAABJRU5ErkJggg==</pentrails><costumes><list struct="atomic" id="3966"></list></costumes><sounds><list struct="atomic" id="3967"></list></sounds><variables></variables><blocks></blocks><scripts></scripts><sprites select="1"><sprite name="Sprite" idx="1" x="0" y="0" heading="90" scale="1" volume="100" pan="0" rotation="1" draggable="true" costume="0" color="0,0,0,1" pen="tip" id="3972"><costumes><list struct="atomic" id="3973"></list></costumes><sounds><list struct="atomic" id="3974"></list></sounds><blocks></blocks><variables></variables><scripts><script x="20" y="20"><custom-block s="segments in tree %n"><l></l></custom-block></script><script x="20" y="53"><custom-block s="alternate segments in tree %n"><l></l></custom-block></script><script x="20" y="86"><block s="reportVariadicSum"><list><l>1</l><block s="reportVariadicSum"><list><custom-block s="segments in tree %n"><block s="reportDifference"><block var="level"/><l>1</l></block></custom-block><custom-block s="segments in tree %n"><block s="reportDifference"><block var="level"/><l>1</l></block></custom-block></list></block></list></block></script><script x="20" y="169.83333333333337"><custom-block s="triangles in level %n fractal"><l></l></custom-block></script><script x="20" y="202.83333333333337"><custom-block s="%n !"><l></l></custom-block></script><script x="20" y="235.83333333333337"><custom-block s="letter count %l"><l/></custom-block></script><script x="20" y="265.83333333333337"><custom-block s="my join words %l"><l/></custom-block></script></scripts></sprite><watcher var="count" style="normal" x="10" y="10" color="243,118,29" hidden="true"/><watcher var="Pascal list" style="normal" x="10" y="40.000001999999995" color="243,118,29" hidden="true"/><watcher var="flavors" style="normal" x="10" y="177.500004" color="243,118,29" hidden="true"/></sprites></stage><variables><variable name="count"><l>0</l></variable><variable name="Pascal list"><list struct="atomic" id="4014"></list></variable><variable name="flavors"><list struct="atomic" id="4015">chocolate pudding,pumpkin,rum raisin,ginger,cinnamon,creme caramel,raspberry sorbet,vanilla bean</list></variable></variables></scene></scenes></project>